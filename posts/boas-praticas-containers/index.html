<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Boas práticas em containers | Blog do Craudio</title><meta name=keywords content="containers,docker"><meta name=description content="Lista de boas práticas e otimizações em containers"><meta name=author content="Claudio Filho"><link rel=canonical href=https://craudio.com.br/posts/boas-praticas-containers/><link crossorigin=anonymous href=/assets/css/stylesheet.e2ea0dcff66eeb370443a78a7734f0247315cdf3138124920576eaaef808bf5e.css integrity="sha256-4uoNz/Zu6zcEQ6eKdzTwJHMVzfMTgSSSBXbqrvgIv14=" rel="preload stylesheet" as=style><link rel=icon href=https://craudio.com.br/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://craudio.com.br/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://craudio.com.br/favicon-32x32.png><link rel=apple-touch-icon href=https://craudio.com.br/apple-touch-icon.png><link rel=mask-icon href=https://craudio.com.br/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://craudio.com.br/posts/boas-praticas-containers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://craudio.com.br/posts/boas-praticas-containers/"><meta property="og:site_name" content="Blog do Craudio"><meta property="og:title" content="Boas práticas em containers"><meta property="og:description" content="Lista de boas práticas e otimizações em containers"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-19T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-19T00:00:00+00:00"><meta property="article:tag" content="Containers"><meta property="article:tag" content="Docker"><meta name=twitter:card content="summary"><meta name=twitter:title content="Boas práticas em containers"><meta name=twitter:description content="Lista de boas práticas e otimizações em containers"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://craudio.com.br/posts/"},{"@type":"ListItem","position":2,"name":"Boas práticas em containers","item":"https://craudio.com.br/posts/boas-praticas-containers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Boas práticas em containers","name":"Boas práticas em containers","description":"Lista de boas práticas e otimizações em containers","keywords":["containers","docker"],"articleBody":"Segurança em containers docker e otimização de imagens. Neste artigo buscaremos passar por alguns dos muitos topicos relacionados a segurança e otmização de containers.\nEm especifico vamos utilizar e exemplificar usando o Docker, um dos mais conhecidos e usados.\nO objetivo é listar possíveis brechas de segurança e discutir como mitiga-las, através de pequenos exemplos e textos.\nSuperficies de Ataques Os containers modernos, revolucionaram a forma que desenvolvemos e entregamos software. Por serem leves e de muito mais facil distribuição, possuem esta vantagem em relação a VMs, carregam consigo todas bibliotecas e dependencias necessárias para execução de aplicações.\nOferecem nativamente um bom modelo de segurança e isolamento, com a utilização dos namespaces do kernel, para executar processos em seu próprio quadrado, além de usarem cgroups para isolamento de uso de CPU e Memoria.\nMuitas vezes o cenário basico, e built in de segurança do Docker é o suficiente para iniciarmos seu aprendizado, testarmos alguma coisa especifica, trabalharmos offline e afins.\nPorém quando voltamos os olhos para produção, aplicações publicamente acessiveis, multiplos requests, interação entre containers, execução em orquestradores (Swarm, Kubernetes), nos deparamos com muitos pontos de segurança que valem a atenção e cuidados, para que não se torne um grande problema a execução de containers.\nVamos nos proximos tópicos trabalhar em cima destes possíveis cenários que envolvem executar containers em produção, pensando inicialmente em três superficies de ataque. As superficies estão descritas abaixo.\nHost - O local onde o docker e seus containers estão em execução, onde compartilham recurso, armazenam imagens locais, pode ser nossa maquina pessoal, um servidor na GCP, um cluster K8s na AWS ou afins.\nClient - O CLI, o docker instalado neste host, a forma que interagimos com os containers, com comandos e configurações a serem passadas ao Docker Daemon\nRegistry - Onde armazenamos nossas imagens(geralmente de forma remota), de onde o docker coleta imagens padrão e conhecidas, por exempo o registry DockerHub, o AWS ecr, ou o GCP Artifact Registry.\nAlém destes tópicos também trataremos de otimização de imagens, e mostrando como a otimização colabora no quesito segurança.\nTop 10 Neste tópico provavelmente não seguiremos todos os TOP 10 OWASP, porém muitos dos problemas aqui descritos também são tratados no artigo em questão.\nObtivemos de diversas fontes os tópicos que aqui vamos tratar, e que podemos encontrar muitas vezes descritos com outro nome, ou relacionados com outras questões.\nO objetivo é ser o mais sucinto e exemplar possível, descrevendo o problema, e sua mitigação de forma imediata. Trazendo um sentimento de cartilha a ser seguida, que fique facil de bater o olho, entender o problema e ver alternativas para mitiga-lo.\nPodemos também, destrinchar cada um dos tópicos com exemplos mais completos.\n1 - Host ou imagem docker com vulnerabilidades conhecidas Descrição: Imagem do host ou container docker com vulnerabilidades (CVEs) abertos e conhecidos\nMitigação:\nAtualize sempre o host, o serviço (K8s, DockerCLI) e a imagem do container Use imagens oficiais e atualizadas Faça scan de segurança com: trivy image docker scan Ferramentas como Snyk ou Docker Scout Exemplo:\nExecutando ferramenta Trivy, para scan de imagem oficial do nginx. Mesmo com uma imagem oficial vemos a quantiade de CVEs.\nVer Mais\n2. Imagens comprometidas Descrição:\nImagens de Host ou containers comprometido, contendo código maliciosos\nMitigação:\nUse imagens de fontes confiáveis Evite utilizar imagens de usuários em registry publicos Verifique assinaturas com: Docker Content Trust cosign (do projeto sigstore) Exemplo:\nNo dockerhub ou em registry, procure sempre imagens oficiais, que contenham quantidade de downloads significativas e conhecidas.\nPodemos usar o Docker Content Trust, ou verificar imagens com o cosign.\nVer Mais\n3. Uso de credenciais direto na imagem Descrição:\nSenhas ou tokens salvos no Dockerfile ou na imagem final\nMitigação:\nNunca salve segredos no Dockerfile Use docker secrets, Vault, ou Kubernetes Secrets, ou até variaveis de ambiente Escaneie com algum verificador estatico que procura por senhas Exemplo:\nNunca expor variaveis de ambiente com secrets ou afins.\nSempre buscar utilizar variaveis de ambiente em tempo de execução e não de build\nVer Mais\n4. Permissões excessivas (root user) Descrição:\nExecutar como root dentro do container permite escalar privilégios, e tentar acesso a outras partes do host ou outros containers.\nMitigação:\nUse a instrução USER appuser no Dockerfile Habilite políticas com AppArmor ou PodSecurityPolicy(K8s) Exemplo: Podemos no dockerfile definir um USER especifico que vai conseguir rodar o que precisamos, e que este user não consiga escalar para root.\nVer Mais\n5. Layers não otimizadas com arquivos sensíveis Descrição:\nArquivos podem ficar acessíveis em layers mesmo após rm\nMitigação:\nUse comandos combinados no RUN Adote multi-stage builds Exemplo:\nNa arquitetura do container, sabemos que trabalhamos em camadas, com isso um RUN gera uma camada, enquanto um RUN abaixo gera outra camada, ou seja, o que foi construido no primeiro RUN, esta em uma camada diferente da execução, podendo carregar consigo algum problema, e por mais que os arquivos existam em determinada camada, podem não ser os mesmos adicionados anteriormente.\n#O rm não irá apagar o arquivo, pois ele esta readonly e na camada anterior FROM anyimage RUN curl -o topsecret.sh https://www.scriptqualquer.com/scriptsecreto \u0026\u0026 \\ chmod +x scriptsecreto.sh RUN sh topsecret.sh RUN rm topsecret.sh #Desta forma o arquivo sera baixado executado e removido na mesma camada. FROM anyimage RUN curl -o topsecret.sh https://www.scriptqualquer.com/scriptsecreto \u0026\u0026 \\ chmod +x topsecret.sh \u0026\u0026 \\ rm topsecret.sh Ver Mais\n6. Execução de código malicioso via ENTRYPOINT ou CMD Descrição:\nExecução inesperada no startup do container\nMitigação:\nInspecione o Dockerfile e o comportamento do CMD/ENTRYPOINT Quando for construir uma imagem, importante entender o que esta no entrypoint Exemplo:\nMuitas imagens utilizam entrypoints externos, como entrypoint.sh, ou de alguma outra forma, e é importante entender o que o entrypoint esta fazendo, pois ao executar sua imagem ele será chamado.\nEntenda o entrypoint seja no Dockerfile ou no arquivo externo.\nVer Mais\n7. Dependências comprometidas (supply chain) Descrição:\nBinários e pacotes baixados em tempo de build estão comprometidos\nMitigação:\nFixe versões e valide hashes Prefira pacotes de repositórios oficiais Exemplo:\nAo fazer download, procure comparar o hash do arquivo com o hash passado pelo provedor.\nSempre fixe as versões de imagem, de libs, e qualquer outra ferramenta usada na imagem, isto evita além de segurança outros problemas.\nProcure usar SBOM e/ou SLSA e comandos que verifiquem integridade e validade de softwares.\nVer Mais\n8. Ataques via COPY de arquivos maliciosos Descrição:\nArquivos suspeitos copiados para a imagem.\nMitigação:\nUse .dockerignore Limite o escopo do COPY Exemplo:\nUtilize o .dockerignore ignorando .env, *.pem, id_rsa, etc.\nPrefira sempre fazer o COPY acertivo, apenas com o que a imagem realmente necessita, evite o COPY .\nVer Mais\n9. Container Escape Descrição:\nAtaques que exploram o kernel ou runtime para escapar do container.\nMitigação:\nAtualize kernel e Docker Evite --privileged Use containers rootless Exemplo:\nNunca usar a flag --privileged ela aumenta muito as permissões do container, habilitando acesso a diretórios do host antes proibidos.\nEvite sempre que possível rodar em pipelines docker in docker, com acesso ao /var/lib/docker\nrunc com cve que habilitava container escape CVE-2019-5736\nVer Mais\n10. Builds não reproduzíveis Descrição:\nImagens que não produzem o mesmo resultado em builds diferentes\nMitigação:\nUse --no-cache Evite latest para imagens ou dependencias Evite variaveis de ambiente em tempo de build, configuração vem do ambiente Defina versões especificas para tudo o que for possível Em pipelines utilize o conceito de construa uma vez e use muitas Exemplo:\nPodemos considerar um pip install onde as dependencias não possuem valores definidos.\nQuando formos construir novamente, pode ser que uma latest com alguma breaking change ou nova CVE vai ser usada, quebrando nossa imagem.\nVer Mais\nOtimização de imagens Sobre o tema de otimização de imagens de containers, estamos falando sobre deixar a imagem mais performatica e segura. Como conseguimos isto?\nAtualmente, um ou dois conceitos(distroless, undistro) e duas ferramentas(melange e apko) nos permitem conseguir deixar a imagem minimalista, ou seja com o minimo possível de dependencias ou bibliotecas, consequentemente pesando uma quantidade de megas muito menor, o que facilita o pull e push para registry, e também deixando praticamente com 0 vulnerabilidades.\nMas e além destas duas ferramentas, como nativamente podemos deixar a imagem mais otimizada?\nPontos importantes e nativos do Docker para otimização das imagens Otimização de layers Aqui vemos dois exemplos de dockerfile, assim como fizemos em um dos tópicos acima, temos a execução unica de varios comandos em um exemplo ruim, que irá gerar inumeras layers, e não irá apagar diversos arquivos, pois eles estão no nivel acima.\nE o exemplo bom, onde rodamos os comandos inline, estando tudo em execução em uma mesma camada, que será limpa ao fim dos comandos.\n#Exemplo ruim FROM ubuntu:latest RUN apt-get update -y RUN apt-get install -y curl RUN apt-get install -y vim RUN apt-get clean autoclean RUN rm -rf /var/lib/{apt,dpkg,cache,log}/ ENTRYPOINT [\"/bin/bash\"] #Exemplo bom FROM ubuntu:latest RUN apt-get update -y \u0026\u0026 \\ apt-get install -y curl vim \u0026\u0026 \\ apt-get clean autoclean \u0026\u0026 \\ rm -rf /var/lib/{apt,dpkg,cache,log}/ ENTRYPOINT [\"/bin/bash\"] Vejamos a diferença de layers com o comando docker history , apesar de não ter uma redução significativa no exemplo, vemos menos layers.\nAlém de fazer os comandos encadeados, uma importante abordagem é a ordem de instalação das coisas, pensar que o docker faz cache das layers nos permite ter abordagens de rodar um comando mais pesado primeiro e sozinho para que numa segunda rodada ele ja esteja cacheado.\nO dockerfile abaixo irá cachear o run pesado e na proxima execução estar a prova de falhas pelo curl.\nCachear o apt-get update também pode ser um erro, já que algum tempo depois os pacotes nas versões cacheadas não serão mais usados, e você estara usando uma versão antiga.\n#Exemplo1 FROM debian:latest RUN RUN apt-get update \u0026\u0026 \\ apt-get install -y curl ENTRYPOINT ... No exemplo abaixo, imagine numa pipeline, o comando que leva mais tempo gasta 5 minutos foi executado, porém um apt-get posterior falhou, quando tentar fazer o rebuild da imagem numa proxima execução, gastara novamente os 5 minutos, caso que no primeiro exemplo não gastará caso a layer ja tenha sido cacheada.\n# Exemplo2 FROM debia:latest RUN apt-get update \u0026\u0026 \\ \u0026\u0026 \\ apt-get install -y curl \\ Quando mudamos alguma linha do Dockerfile todos os comandos abaixo rodam novamente, portanto pensar nisso é importante, para otimizar build time e tempo da pipeline de CI.\nUsar pacotes e dependencias necessárias Usar sempre só os pacotes necessários para execução da aplicação, evitar instalar ferramentas de debug e afins em imagens produtivas.\nUsar distribuições minimalistas. Sempre procurar no DockerHub ou fornecedores de imagens as imagens menores, como alpine, debian-slim, ubuntu minimla, distroless.\nCuidado com os problemas de DNS do alpine.\nTamanho do artefato Nada adianta ter uma imagem de 50 MB, se sua aplicação ou artefato gerado (.jar, binario) tiver 3GB, então o tamanho da aplicação e seu artefato influenciam no desempenho da imagem e nos custos gerados por ela.\nMulti Stage Builds Linguagens que possuem artefatos ou arquivos de output se beneficiam de builds multistage, que significa usar um container para construir o artefato e posteriormente copiar o artefato para outra imagem que não irá possúir as muitas bibliotecas e pacotes necessários para o build, reduzindo e otimizando drasticamente a imagem.\nExemplo com golang.\nNeste dockerfile vemos que temos dois estagios, o build e o proximo from, que caracteriza a imagem final onde ficará o artefato, fazendo com que o step de build seja descartado e apenas a imagem final usada.\nFROM golang:1.21 as build WORKDIR $GOPATH/src/app COPY . ./ RUN go get -u RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main . FROM alpine:latest WORKDIR /app COPY --from=build go/src/app/main . EXPOSE 8080 ENTRYPOINT [\"./main\"] Em python, node, javascript em geral também é possível, e podemos encontrar varios exemplos na internet, as pastas que copiamos de cada um pode ser diferente e vale os testes para os determinados caminhos e afins.\nImagens base Muitas empresas tem a projetos e times que mantem imagens base, geralmente o time de devops.\nAs imagens base, são imagens construidas para objetivos especifico para as necessidades da empresa.\nVamos supor que uma empresa utiliza java em seu desenvolvimento, ela irá construir uma imagem base usando o java de sua escolha, com maven, com gerenciadores de sua escolha e ponto final. Posteriormente os times de desenvolvimento pegam esta imagem como base (a utilizam no FROM) e constroem a imagem da aplicação com base nela.\nMuitas vezes possuem uma imagem para build e outra para ser usada em produção, tal qual imagens para desenvolvimento que possuem mais ferramentas para debug.\nPodemos ter estruturas de pipeline para distribuição destas imagens base, que podem ser construidas em periodos certos e automaticamente atualizando todo o parque de aplicações.\nA gestão de imagens base temos maior controle da atualização, das vulnerabilidades e gestão de supply chain gerenciada.\nFacilitam uso de certificados, libs internas e agentes obrigatórios em imagens e formam um padrão minimo a ser seguido por toda aplicação.\nNão é de facil gerenciamento, e exige operação, e apresenta dificuldades quando não temos padrão de linguagem ou versão de linguagens muito distribuidas.\nTalvez seja o cenário ideal para empresas e podemos fazer com ferramentas base do Docker e existem algumas ferramentas que ajudam na criação destasimagens vamos descorrer mais sobre elas logo abaixo.\nDefinindo os termos e ferramentas Distroless: Conceito de imagem docker que contem apenas sua aplicação e suas dependencias, sem bibliotecas extras, sem shell, sem package managers (apt, apk, yum) e nenhum outro programa que não seja necessário para rodar a aplicação.\napko: Auxilia no processo de construção da imagem, ele é quem irá pegar os pacotes e construir a imagem do container com base nas regras da OCI.\nOCI: Open container initiative, é quem regula e controla os conceitos para containers, é uma organização que estabelece padrões para container runtime, image spec, e spc para distribuir containers. Tornando padronizado rodar container hoje no planeta terra, permitindo interoperabilidade.\nWolfi OS: É o sistema undistro (não é um SO completo para rodar num servidor, você não o instala no notebook e usa sua UI por exemplo), que prioriza segurança, desenvolvido pensando em aplicações cloud native, não possuí seu kernel próprio e leva esse conceito de que o container não precisa de milhoes de pacotes ou arquivos para funcionar totalmente ao extremo, levando somente o necessário para dentro da imagem.\nCom estes termos definidos, podemos passar para uma parte mais pratica, vamos então criar uma imagem usando estes conceitos, porém gostaria de iniciar mostrando algumas imagens ja existentes e fornecidas pela changuard em seu site, mostrar as diferenças entre elas, e como com este conceito distroless elas promovem segurança e performance.\nImagens Chainguard As imagens chainguard estão disponiveis para uso publico, porém versões especificas são pagas, o que é uma barreira inicial para uso das imagens, já que estamos sucetiveis a mudanças na latest.\nPodemos comparar uma imagem distroless da chainguard com uma oficial do dockerhub, e usando o trivy comparar a quantidade de vulnerabilidades presentes.\nAbaixo um exemplo, onde evidenciamos as vulnerabilidades e também a diferença de tamanho das imagens.\n![./images/trivy-pythonvuln.png]\nVemos que a imagem da chainguard tem um tamanho infinitamente menor do que uma imagem python latest, temos também outras imagens menores do python, como o python:alpine, que muitas vezes(nem sempre) vem sem vulnerabilidades, então vemos uma logica aqui, quanto menor a imagem menor o numero de vulnerabilidades, e isto geralmente é verdade, pois são menos pacotes adjascentes e menos bibliotecas, pacotes para serem gerenciados, ou seja reduzimos o campo de ataque.\nCriando uma imagem base com wolfi e apko O apko tem uma linguagem de escrita em yaml, um arquivo declarativo que deixa em forma de pipeline o que desejamos fazer\nAbaixo um exemplo do arquivo, que também pode ser visto no path apko-python.yaml\ncontents: keyring: - https://packages.wolfi.dev/os/wolfi-signing.rsa.pub repositories: - https://packages.wolfi.dev/os packages: - wolfi-base - openssl - python3 environment: PATH: /usr/local/sbin:/usr/local/bin:/usr/bin:/usr/sbin:/sbin:/bin archs: - amd64 Estamos dizendo que queremos construir um pacote com apko, contendo wolfi-base, openssl e python3, e com o seguinte variavel de ambiente para PATH. Em seguida definimos a arquitetura amd64, podendo ser arm, entre outras.\nPara buidar temos de ter a ferramenta instalada e rodamos\napko build nome-imagem pacoteoutput.tar apko build apko-python.yaml python-base python-base.tar De forma muito rapida é criado um .tar contendo a imagem, e também seus arquivos de metadata do sbom, que contem toda info sobre as bibliotecas ali instaladas.\nEm seguida para transformar o .tar em uma imagem, usamos o comando docker load C\ndocker load -i .tar E posteriormente vemos a imagem base já em nossas imagens disponiveis.\nE desta forma para qualquer outra linguagem ou pacote.\nA um tempo já construi uma imagem usando apko que continha o kubectl e o awscli, porém perdi este projeto, assim que tiver mais um tempo voltamos com este tema.\nEsta ferramenta é bacana para construção de imagens base e também gerenciamento de supply chain, como SBOM, SLSA, preciso de maiores estudos nesta area de metadados do container e bibliotecas, e podemos também voltar com este assunto no futuro.\nConclusão Existe um mundo de vulnerabilidades e mitigações a serem feitas numa imagem de container, seguir as boas praticas é fundamente para diminuirmos superficie de ataque e otimizarmos imagem.\nNem sempre é possível fazer tudo, porém o bom não pode ser inimigo do ótimo, e uma pequena ação deste estilo já causa beneficios que iremos colher na utilização de containers.\nEspero que a documentação esteja clara e esclarecedora.\nReferencias OWASP-TOP10\nSysDig: Container security best practices\nDocker Attack Surface\nChainguard\nChainguard - Melange\nChainguard - APKO\nDocker Security Cheat Sheet\nCIS Security Benchmark - Docker\nSTRIDE Framework\nDocker ArchitecturIn this guide, you’ll learn how to build a software package with melange. To deme - Aquaseq\n","wordCount":"2944","inLanguage":"en","datePublished":"2025-06-19T00:00:00Z","dateModified":"2025-06-19T00:00:00Z","author":{"@type":"Person","name":"Claudio Filho"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://craudio.com.br/posts/boas-praticas-containers/"},"publisher":{"@type":"Organization","name":"Blog do Craudio","logo":{"@type":"ImageObject","url":"https://craudio.com.br/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://craudio.com.br/ accesskey=h title="Blog do Craudio (Alt + H)">Blog do Craudio</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://craudio.com.br/archives title=Posts><span>Posts</span></a></li><li><a href=https://craudio.com.br/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://craudio.com.br/pages/about/ title=About><span>Sobre</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Boas práticas em containers</h1><div class=post-description>Lista de boas práticas e otimizações em containers</div><div class=post-meta><span title='2025-06-19 00:00:00 +0000 UTC'>June 19, 2025</span>&nbsp;·&nbsp;Claudio Filho</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#seguran%c3%a7a-em-containers-docker-e-otimiza%c3%a7%c3%a3o-de-imagens aria-label="Segurança em containers docker e otimização de imagens.">Segurança em containers docker e otimização de imagens.</a></li><li><a href=#superficies-de-ataques aria-label="Superficies de Ataques">Superficies de Ataques</a></li><li><a href=#top-10 aria-label="Top 10">Top 10</a><ul><li><a href=#1---host-ou-imagem-docker-com-vulnerabilidades-conhecidas aria-label="1 - Host ou imagem docker com vulnerabilidades conhecidas">1 - Host ou imagem docker com vulnerabilidades conhecidas</a></li><li><a href=#2-imagens-comprometidas aria-label="2. Imagens comprometidas">2. Imagens comprometidas</a></li><li><a href=#3-uso-de-credenciais-direto-na-imagem aria-label="3. Uso de credenciais direto na imagem">3. Uso de credenciais direto na imagem</a></li><li><a href=#4-permiss%c3%b5es-excessivas-root-user aria-label="4. Permissões excessivas (root user)">4. Permissões excessivas (root user)</a></li><li><a href=#5-layers-n%c3%a3o-otimizadas-com-arquivos-sens%c3%adveis aria-label="5. Layers não otimizadas com arquivos sensíveis">5. Layers não otimizadas com arquivos sensíveis</a></li><li><a href=#6-execu%c3%a7%c3%a3o-de-c%c3%b3digo-malicioso-via-entrypoint-ou-cmd aria-label="6. Execução de código malicioso via ENTRYPOINT ou CMD">6. Execução de código malicioso via ENTRYPOINT ou CMD</a></li><li><a href=#7-depend%c3%aancias-comprometidas-supply-chain aria-label="7. Dependências comprometidas (supply chain)">7. Dependências comprometidas (supply chain)</a></li><li><a href=#8-ataques-via-copy-de-arquivos-maliciosos aria-label="8. Ataques via COPY de arquivos maliciosos">8. Ataques via COPY de arquivos maliciosos</a></li><li><a href=#9-container-escape aria-label="9. Container Escape">9. Container Escape</a></li><li><a href=#10-builds-n%c3%a3o-reproduz%c3%adveis aria-label="10. Builds não reproduzíveis">10. Builds não reproduzíveis</a></li></ul></li><li><a href=#otimiza%c3%a7%c3%a3o-de-imagens aria-label="Otimização de imagens">Otimização de imagens</a><ul><li><a href=#pontos-importantes-e-nativos-do-docker-para-otimiza%c3%a7%c3%a3o-das-imagens aria-label="Pontos importantes e nativos do Docker para otimização das imagens">Pontos importantes e nativos do Docker para otimização das imagens</a><ul><li><a href=#otimiza%c3%a7%c3%a3o-de-layers aria-label="Otimização de layers">Otimização de layers</a></li><li><a href=#usar-pacotes-e-dependencias-necess%c3%a1rias aria-label="Usar pacotes e dependencias necessárias">Usar pacotes e dependencias necessárias</a></li><li><a href=#usar-distribui%c3%a7%c3%b5es-minimalistas aria-label="Usar distribuições minimalistas.">Usar distribuições minimalistas.</a></li><li><a href=#tamanho-do-artefato aria-label="Tamanho do artefato">Tamanho do artefato</a></li><li><a href=#multi-stage-builds aria-label="Multi Stage Builds">Multi Stage Builds</a></li><li><a href=#imagens-base aria-label="Imagens base">Imagens base</a></li></ul></li><li><a href=#definindo-os-termos-e-ferramentas aria-label="Definindo os termos e ferramentas">Definindo os termos e ferramentas</a></li><li><a href=#imagens-chainguard aria-label="Imagens Chainguard">Imagens Chainguard</a></li><li><a href=#criando-uma-imagem-base-com-wolfi-e-apko aria-label="Criando uma imagem base com wolfi e apko">Criando uma imagem base com wolfi e apko</a></li></ul></li><li><a href=#conclus%c3%a3o aria-label=Conclusão>Conclusão</a><ul><ul><li><a href=#referencias aria-label=Referencias>Referencias</a></li></ul></ul></li></ul></div></details></div><div class=post-content><h1 id=segurança-em-containers-docker-e-otimização-de-imagens>Segurança em containers docker e otimização de imagens.<a hidden class=anchor aria-hidden=true href=#segurança-em-containers-docker-e-otimização-de-imagens>#</a></h1><p>Neste artigo buscaremos passar por alguns dos muitos topicos relacionados a segurança e otmização de containers.</p><p>Em especifico vamos utilizar e exemplificar usando o Docker, um dos mais conhecidos e usados.</p><p>O objetivo é listar possíveis brechas de segurança e discutir como mitiga-las, através de pequenos exemplos e textos.</p><h1 id=superficies-de-ataques>Superficies de Ataques<a hidden class=anchor aria-hidden=true href=#superficies-de-ataques>#</a></h1><p>Os containers modernos, revolucionaram a forma que desenvolvemos e entregamos software. Por serem leves e de muito mais facil distribuição, possuem esta vantagem em relação a VMs, carregam consigo todas bibliotecas e dependencias necessárias para execução de aplicações.</p><p>Oferecem nativamente um bom modelo de segurança e isolamento, com a utilização dos namespaces do kernel, para executar processos em seu próprio quadrado, além de usarem cgroups para isolamento de uso de CPU e Memoria.</p><p>Muitas vezes o cenário basico, e built in de segurança do Docker é o suficiente para iniciarmos seu aprendizado, testarmos alguma coisa especifica, trabalharmos offline e afins.</p><p>Porém quando voltamos os olhos para produção, aplicações publicamente acessiveis, multiplos requests, interação entre containers, execução em orquestradores (Swarm, Kubernetes), nos deparamos com muitos pontos de segurança que valem a atenção e cuidados, para que não se torne um grande problema a execução de containers.</p><p>Vamos nos proximos tópicos trabalhar em cima destes possíveis cenários que envolvem executar containers em produção, pensando inicialmente em três superficies de ataque. As superficies estão descritas abaixo.</p><p>Host - O local onde o docker e seus containers estão em execução, onde compartilham recurso, armazenam imagens locais, pode ser nossa maquina pessoal, um servidor na GCP, um cluster K8s na AWS ou afins.</p><p>Client - O CLI, o docker instalado neste host, a forma que interagimos com os containers, com comandos e configurações a serem passadas ao Docker Daemon</p><p>Registry - Onde armazenamos nossas imagens(geralmente de forma remota), de onde o docker coleta imagens padrão e conhecidas, por exempo o registry DockerHub, o AWS ecr, ou o GCP Artifact Registry.</p><p>Além destes tópicos também trataremos de otimização de imagens, e mostrando como a otimização colabora no quesito segurança.</p><h1 id=top-10>Top 10<a hidden class=anchor aria-hidden=true href=#top-10>#</a></h1><p>Neste tópico provavelmente não seguiremos todos os TOP 10 OWASP, porém muitos dos problemas aqui descritos também são tratados no artigo em questão.</p><p>Obtivemos de diversas fontes os tópicos que aqui vamos tratar, e que podemos encontrar muitas vezes descritos com outro nome, ou relacionados com outras questões.</p><p>O objetivo é ser o mais sucinto e exemplar possível, descrevendo o problema, e sua mitigação de forma imediata. Trazendo um sentimento de cartilha a ser seguida, que fique facil de bater o olho, entender o problema e ver alternativas para mitiga-lo.</p><p>Podemos também, destrinchar cada um dos tópicos com exemplos mais completos.</p><h2 id=1---host-ou-imagem-docker-com-vulnerabilidades-conhecidas>1 - Host ou imagem docker com vulnerabilidades conhecidas<a hidden class=anchor aria-hidden=true href=#1---host-ou-imagem-docker-com-vulnerabilidades-conhecidas>#</a></h2><p><strong>Descrição:</strong> Imagem do host ou container docker com vulnerabilidades (CVEs) abertos e conhecidos</p><p><strong>Mitigação:</strong></p><ul><li>Atualize sempre o host, o serviço (K8s, DockerCLI) e a imagem do container</li><li>Use imagens oficiais e atualizadas</li><li>Faça scan de segurança com:<ul><li><code>trivy image &lt;imagem></code></li><li><code>docker scan &lt;imagem></code></li><li>Ferramentas como Snyk ou Docker Scout</li></ul></li></ul><p><strong>Exemplo:</strong><br>Executando ferramenta Trivy, para scan de imagem oficial do nginx. Mesmo com uma imagem oficial vemos a quantiade de CVEs.</p><p><img alt=trivy-nginx loading=lazy src=/posts/boas-praticas-containers/images/trivynginx.gif></p><p><a href=./1/index.html>Ver Mais</a></p><hr><h2 id=2-imagens-comprometidas>2. Imagens comprometidas<a hidden class=anchor aria-hidden=true href=#2-imagens-comprometidas>#</a></h2><p><strong>Descrição:</strong><br>Imagens de Host ou containers comprometido, contendo código maliciosos</p><p><strong>Mitigação:</strong></p><ul><li>Use imagens de fontes confiáveis</li><li>Evite utilizar imagens de usuários em registry publicos</li><li>Verifique assinaturas com:<ul><li>Docker Content Trust</li><li>cosign (do projeto sigstore)</li></ul></li></ul><p><strong>Exemplo:</strong><br>No dockerhub ou em registry, procure sempre imagens oficiais, que contenham quantidade de downloads significativas e conhecidas.</p><p><img alt=mongo-registry loading=lazy src=/posts/boas-praticas-containers/images/mongoregistry.png></p><p>Podemos usar o <a href=https://docs.docker.com/engine/security/trust/#client-enforcement-with-docker-content-trust>Docker Content Trust</a>, ou verificar imagens com o cosign.</p><p><a href=./2/index.html>Ver Mais</a></p><hr><h2 id=3-uso-de-credenciais-direto-na-imagem>3. Uso de credenciais direto na imagem<a hidden class=anchor aria-hidden=true href=#3-uso-de-credenciais-direto-na-imagem>#</a></h2><p><strong>Descrição:</strong><br>Senhas ou tokens salvos no Dockerfile ou na imagem final</p><p><strong>Mitigação:</strong></p><ul><li>Nunca salve segredos no <code>Dockerfile</code></li><li>Use <code>docker secrets</code>, <code>Vault</code>, ou <code>Kubernetes Secrets</code>, ou até variaveis de ambiente</li><li>Escaneie com algum verificador estatico que procura por senhas</li></ul><p><strong>Exemplo:</strong><br>Nunca expor variaveis de ambiente com secrets ou afins.</p><p>Sempre buscar utilizar variaveis de ambiente em tempo de execução e não de build</p><p><img alt=secrets loading=lazy src=/posts/boas-praticas-containers/images/secretshardcoded.gif></p><p><a href=./3/index.html>Ver Mais</a></p><hr><h2 id=4-permissões-excessivas-root-user>4. Permissões excessivas (root user)<a hidden class=anchor aria-hidden=true href=#4-permissões-excessivas-root-user>#</a></h2><p><strong>Descrição:</strong><br>Executar como root dentro do container permite escalar privilégios, e tentar acesso a outras partes do host ou outros containers.</p><p><strong>Mitigação:</strong></p><ul><li>Use a instrução <code>USER appuser</code> no <code>Dockerfile</code></li><li>Habilite políticas com AppArmor ou PodSecurityPolicy(K8s)</li></ul><p><strong>Exemplo:</strong>
Podemos no dockerfile definir um USER especifico que vai conseguir rodar o que precisamos, e que este user não consiga escalar para root.</p><p><a href=./4/index.html>Ver Mais</a></p><hr><h2 id=5-layers-não-otimizadas-com-arquivos-sensíveis>5. Layers não otimizadas com arquivos sensíveis<a hidden class=anchor aria-hidden=true href=#5-layers-não-otimizadas-com-arquivos-sensíveis>#</a></h2><p><strong>Descrição:</strong><br>Arquivos podem ficar acessíveis em layers mesmo após <code>rm</code></p><p><strong>Mitigação:</strong></p><ul><li>Use comandos combinados no <code>RUN</code></li><li>Adote <code>multi-stage builds</code></li></ul><p><strong>Exemplo:</strong><br>Na arquitetura do container, sabemos que trabalhamos em camadas, com isso um RUN gera uma camada, enquanto um RUN abaixo gera outra camada, ou seja, o que foi construido no primeiro RUN, esta em uma camada diferente da execução, podendo carregar consigo algum problema, e por mais que os arquivos existam em determinada camada, podem não ser os mesmos adicionados anteriormente.</p><pre tabindex=0><code>#O rm não irá apagar o arquivo, pois ele esta readonly e na camada anterior

FROM anyimage

RUN curl -o topsecret.sh https://www.scriptqualquer.com/scriptsecreto &amp;&amp; \
    chmod +x scriptsecreto.sh 

RUN sh topsecret.sh  

RUN rm topsecret.sh
</code></pre><pre tabindex=0><code>#Desta forma o arquivo sera baixado executado e removido na mesma camada.
FROM anyimage


RUN curl -o topsecret.sh https://www.scriptqualquer.com/scriptsecreto &amp;&amp; \
    chmod +x topsecret.sh &amp;&amp; \
    rm topsecret.sh
</code></pre><p><a href=./5/index.html>Ver Mais</a></p><hr><h2 id=6-execução-de-código-malicioso-via-entrypoint-ou-cmd>6. Execução de código malicioso via ENTRYPOINT ou CMD<a hidden class=anchor aria-hidden=true href=#6-execução-de-código-malicioso-via-entrypoint-ou-cmd>#</a></h2><p><strong>Descrição:</strong><br>Execução inesperada no startup do container</p><p><strong>Mitigação:</strong></p><ul><li>Inspecione o <code>Dockerfile</code> e o comportamento do <code>CMD/ENTRYPOINT</code></li><li>Quando for construir uma imagem, importante entender o que esta no entrypoint</li></ul><p><strong>Exemplo:</strong><br>Muitas imagens utilizam entrypoints externos, como entrypoint.sh, ou de alguma outra forma, e é importante entender o que o entrypoint esta fazendo, pois ao executar sua imagem ele será chamado.</p><p>Entenda o entrypoint seja no Dockerfile ou no arquivo externo.</p><p><a href=./6/index.html>Ver Mais</a></p><hr><h2 id=7-dependências-comprometidas-supply-chain>7. Dependências comprometidas (supply chain)<a hidden class=anchor aria-hidden=true href=#7-dependências-comprometidas-supply-chain>#</a></h2><p><strong>Descrição:</strong><br>Binários e pacotes baixados em tempo de build estão comprometidos</p><p><strong>Mitigação:</strong></p><ul><li>Fixe versões e valide hashes</li><li>Prefira pacotes de repositórios oficiais</li></ul><p><strong>Exemplo:</strong><br>Ao fazer download, procure comparar o hash do arquivo com o hash passado pelo provedor.</p><p>Sempre fixe as versões de imagem, de libs, e qualquer outra ferramenta usada na imagem, isto evita além de segurança outros problemas.</p><p>Procure usar SBOM e/ou SLSA e comandos que verifiquem integridade e validade de softwares.</p><p><a href=./7/index.html>Ver Mais</a></p><hr><h2 id=8-ataques-via-copy-de-arquivos-maliciosos>8. Ataques via <code>COPY</code> de arquivos maliciosos<a hidden class=anchor aria-hidden=true href=#8-ataques-via-copy-de-arquivos-maliciosos>#</a></h2><p><strong>Descrição:</strong><br>Arquivos suspeitos copiados para a imagem.</p><p><strong>Mitigação:</strong></p><ul><li>Use <code>.dockerignore</code></li><li>Limite o escopo do <code>COPY</code></li></ul><p><strong>Exemplo:</strong><br>Utilize o <code>.dockerignore</code> ignorando <code>.env</code>, <code>*.pem</code>, <code>id_rsa</code>, etc.</p><p>Prefira sempre fazer o <code>COPY</code> acertivo, apenas com o que a imagem realmente necessita, evite o <code>COPY .</code></p><p><a href=./8/index.html>Ver Mais</a></p><hr><h2 id=9-container-escape>9. Container Escape<a hidden class=anchor aria-hidden=true href=#9-container-escape>#</a></h2><p><strong>Descrição:</strong><br>Ataques que exploram o kernel ou runtime para escapar do container.</p><p><strong>Mitigação:</strong></p><ul><li>Atualize kernel e Docker</li><li>Evite <code>--privileged</code></li><li>Use containers rootless</li></ul><p><strong>Exemplo:</strong></p><p>Nunca usar a flag <code>--privileged</code> ela aumenta muito as permissões do container, habilitando acesso a diretórios do host antes proibidos.</p><p>Evite sempre que possível rodar em pipelines docker in docker, com acesso ao <code>/var/lib/docker</code></p><p>runc com cve que habilitava container escape <a href=https://aws.amazon.com/blogs/compute/anatomy-of-cve-2019-5736-a-runc-container-escape/>CVE-2019-5736</a></p><p><a href=./9/index.html>Ver Mais</a></p><hr><h2 id=10-builds-não-reproduzíveis>10. Builds não reproduzíveis<a hidden class=anchor aria-hidden=true href=#10-builds-não-reproduzíveis>#</a></h2><p><strong>Descrição:</strong><br>Imagens que não produzem o mesmo resultado em builds diferentes</p><p><strong>Mitigação:</strong></p><ul><li>Use <code>--no-cache</code></li><li>Evite <code>latest</code> para imagens ou dependencias</li><li>Evite variaveis de ambiente em tempo de build, configuração vem do ambiente</li><li>Defina versões especificas para tudo o que for possível</li><li>Em pipelines utilize o conceito de construa uma vez e use muitas</li></ul><p><strong>Exemplo:</strong><br>Podemos considerar um <code>pip install</code> onde as dependencias não possuem valores definidos.</p><p>Quando formos construir novamente, pode ser que uma latest com alguma breaking change ou nova CVE vai ser usada, quebrando nossa imagem.</p><p><a href=./10/index.html>Ver Mais</a></p><hr><h1 id=otimização-de-imagens>Otimização de imagens<a hidden class=anchor aria-hidden=true href=#otimização-de-imagens>#</a></h1><p>Sobre o tema de otimização de imagens de containers, estamos falando sobre deixar a imagem mais performatica e segura. Como conseguimos isto?</p><p>Atualmente, um ou dois conceitos(distroless, undistro) e duas ferramentas(melange e apko) nos permitem conseguir deixar a imagem minimalista, ou seja com o minimo possível de dependencias ou bibliotecas, consequentemente pesando uma quantidade de megas muito menor, o que facilita o pull e push para registry, e também deixando praticamente com 0 vulnerabilidades.</p><p>Mas e além destas duas ferramentas, como nativamente podemos deixar a imagem mais otimizada?</p><h2 id=pontos-importantes-e-nativos-do-docker-para-otimização-das-imagens>Pontos importantes e nativos do Docker para otimização das imagens<a hidden class=anchor aria-hidden=true href=#pontos-importantes-e-nativos-do-docker-para-otimização-das-imagens>#</a></h2><h3 id=otimização-de-layers>Otimização de layers<a hidden class=anchor aria-hidden=true href=#otimização-de-layers>#</a></h3><p>Aqui vemos dois exemplos de dockerfile, assim como fizemos em um dos tópicos acima, temos a execução unica de varios comandos em um exemplo ruim, que irá gerar inumeras layers, e não irá apagar diversos arquivos, pois eles estão no nivel acima.</p><p>E o exemplo bom, onde rodamos os comandos inline, estando tudo em execução em uma mesma camada, que será limpa ao fim dos comandos.</p><pre tabindex=0><code>#Exemplo ruim 

FROM ubuntu:latest

RUN apt-get update -y 

RUN apt-get install -y curl 

RUN apt-get install -y vim

RUN apt-get clean autoclean

RUN rm -rf /var/lib/{apt,dpkg,cache,log}/

ENTRYPOINT [&#34;/bin/bash&#34;]
</code></pre><pre tabindex=0><code>#Exemplo bom 

FROM ubuntu:latest

RUN apt-get update -y &amp;&amp; \
    apt-get install -y curl vim &amp;&amp; \
    apt-get clean autoclean &amp;&amp; \
    rm -rf /var/lib/{apt,dpkg,cache,log}/

ENTRYPOINT [&#34;/bin/bash&#34;]
</code></pre><p>Vejamos a diferença de layers com o comando <code>docker history &lt;nome imagem></code>, apesar de não ter uma redução significativa no exemplo, vemos menos layers.</p><p><img alt="docker layers" loading=lazy src=/posts/boas-praticas-containers/images/dockerlayers.png></p><p>Além de fazer os comandos encadeados, uma importante abordagem é a ordem de instalação das coisas, pensar que o docker faz cache das layers nos permite ter abordagens de rodar um comando mais pesado primeiro e sozinho para que numa segunda rodada ele ja esteja cacheado.</p><p>O dockerfile abaixo irá cachear o run pesado e na proxima execução estar a prova de falhas pelo curl.</p><p>Cachear o apt-get update também pode ser um erro, já que algum tempo depois os pacotes nas versões cacheadas não serão mais usados, e você estara usando uma versão antiga.</p><pre tabindex=0><code>#Exemplo1

FROM debian:latest

RUN &lt;comando pesado&gt;

RUN apt-get update &amp;&amp; \
    apt-get install -y curl 

ENTRYPOINT ... 
</code></pre><p>No exemplo abaixo, imagine numa pipeline, o comando que leva mais tempo gasta 5 minutos foi executado, porém um apt-get posterior falhou, quando tentar fazer o rebuild da imagem numa proxima execução, gastara novamente os 5 minutos, caso que no primeiro exemplo não gastará caso a layer ja tenha sido cacheada.</p><pre tabindex=0><code># Exemplo2 

FROM debia:latest

RUN apt-get update &amp;&amp; \
    &lt;comando pesado&gt; &amp;&amp; \ 
    apt-get install -y curl \
</code></pre><p>Quando mudamos alguma linha do Dockerfile todos os comandos abaixo rodam novamente, portanto pensar nisso é importante, para otimizar build time e tempo da pipeline de CI.</p><h3 id=usar-pacotes-e-dependencias-necessárias>Usar pacotes e dependencias necessárias<a hidden class=anchor aria-hidden=true href=#usar-pacotes-e-dependencias-necessárias>#</a></h3><p>Usar sempre só os pacotes necessários para execução da aplicação, evitar instalar ferramentas de debug e afins em imagens produtivas.</p><h3 id=usar-distribuições-minimalistas>Usar distribuições minimalistas.<a hidden class=anchor aria-hidden=true href=#usar-distribuições-minimalistas>#</a></h3><p>Sempre procurar no DockerHub ou fornecedores de imagens as imagens menores, como alpine, debian-slim, ubuntu minimla, distroless.</p><p>Cuidado com os problemas de DNS do alpine.</p><h3 id=tamanho-do-artefato>Tamanho do artefato<a hidden class=anchor aria-hidden=true href=#tamanho-do-artefato>#</a></h3><p>Nada adianta ter uma imagem de 50 MB, se sua aplicação ou artefato gerado (.jar, binario) tiver 3GB, então o tamanho da aplicação e seu artefato influenciam no desempenho da imagem e nos custos gerados por ela.</p><h3 id=multi-stage-builds>Multi Stage Builds<a hidden class=anchor aria-hidden=true href=#multi-stage-builds>#</a></h3><p>Linguagens que possuem artefatos ou arquivos de output se beneficiam de builds multistage, que significa usar um container para construir o artefato e posteriormente copiar o artefato para outra imagem que não irá possúir as muitas bibliotecas e pacotes necessários para o build, reduzindo e otimizando drasticamente a imagem.</p><p>Exemplo com golang.</p><p>Neste dockerfile vemos que temos dois estagios, o build e o proximo from, que caracteriza a imagem final onde ficará o artefato, fazendo com que o step de build seja descartado e apenas a imagem final usada.</p><pre tabindex=0><code>FROM golang:1.21 as build 

WORKDIR $GOPATH/src/app 

COPY . ./ 

RUN go get -u 
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main . 


FROM alpine:latest 

WORKDIR /app

COPY --from=build go/src/app/main .

EXPOSE 8080 

ENTRYPOINT [&#34;./main&#34;]
</code></pre><p>Em python, node, javascript em geral também é possível, e podemos encontrar varios exemplos na internet, as pastas que copiamos de cada um pode ser diferente e vale os testes para os determinados caminhos e afins.</p><h3 id=imagens-base>Imagens base<a hidden class=anchor aria-hidden=true href=#imagens-base>#</a></h3><p>Muitas empresas tem a projetos e times que mantem imagens base, geralmente o time de devops.</p><p>As imagens base, são imagens construidas para objetivos especifico para as necessidades da empresa.</p><p>Vamos supor que uma empresa utiliza java em seu desenvolvimento, ela irá construir uma imagem base usando o java de sua escolha, com maven, com gerenciadores de sua escolha e ponto final. Posteriormente os times de desenvolvimento pegam esta imagem como base (a utilizam no FROM) e constroem a imagem da aplicação com base nela.</p><p>Muitas vezes possuem uma imagem para build e outra para ser usada em produção, tal qual imagens para desenvolvimento que possuem mais ferramentas para debug.</p><p>Podemos ter estruturas de pipeline para distribuição destas imagens base, que podem ser construidas em periodos certos e automaticamente atualizando todo o parque de aplicações.</p><p>A gestão de imagens base temos maior controle da atualização, das vulnerabilidades e gestão de supply chain gerenciada.</p><p>Facilitam uso de certificados, libs internas e agentes obrigatórios em imagens e formam um padrão minimo a ser seguido por toda aplicação.</p><p>Não é de facil gerenciamento, e exige operação, e apresenta dificuldades quando não temos padrão de linguagem ou versão de linguagens muito distribuidas.</p><p>Talvez seja o cenário ideal para empresas e podemos fazer com ferramentas base do Docker e existem algumas ferramentas que ajudam na criação destasimagens vamos descorrer mais sobre elas logo abaixo.</p><h2 id=definindo-os-termos-e-ferramentas>Definindo os termos e ferramentas<a hidden class=anchor aria-hidden=true href=#definindo-os-termos-e-ferramentas>#</a></h2><p><strong>Distroless:</strong> Conceito de imagem docker que contem apenas sua aplicação e suas dependencias, sem bibliotecas extras, sem shell, sem package managers (apt, apk, yum) e nenhum outro programa que não seja necessário para rodar a aplicação.</p><p><strong>apko:</strong> Auxilia no processo de construção da imagem, ele é quem irá pegar os pacotes e construir a imagem do container com base nas regras da OCI.</p><p><strong>OCI:</strong> Open container initiative, é quem regula e controla os conceitos para containers, é uma organização que estabelece padrões para container runtime, image spec, e spc para distribuir containers. Tornando padronizado rodar container hoje no planeta terra, permitindo interoperabilidade.</p><p><strong>Wolfi OS:</strong> É o sistema undistro (não é um SO completo para rodar num servidor, você não o instala no notebook e usa sua UI por exemplo), que prioriza segurança, desenvolvido pensando em aplicações cloud native, não possuí seu kernel próprio e leva esse conceito de que o container não precisa de milhoes de pacotes ou arquivos para funcionar totalmente ao extremo, levando somente o necessário para dentro da imagem.</p><p>Com estes termos definidos, podemos passar para uma parte mais pratica, vamos então criar uma imagem usando estes conceitos, porém gostaria de iniciar mostrando algumas imagens ja existentes e fornecidas pela changuard em seu site, mostrar as diferenças entre elas, e como com este conceito distroless elas promovem segurança e performance.</p><h2 id=imagens-chainguard>Imagens Chainguard<a hidden class=anchor aria-hidden=true href=#imagens-chainguard>#</a></h2><p>As <a href=https://images.chainguard.dev/>imagens chainguard</a> estão disponiveis para uso publico, porém versões especificas são pagas, o que é uma barreira inicial para uso das imagens, já que estamos sucetiveis a mudanças na latest.</p><p>Podemos comparar uma imagem distroless da chainguard com uma oficial do dockerhub, e usando o trivy comparar a quantidade de vulnerabilidades presentes.</p><p>Abaixo um exemplo, onde evidenciamos as vulnerabilidades e também a diferença de tamanho das imagens.</p><p>![./images/trivy-pythonvuln.png]</p><p>Vemos que a imagem da chainguard tem um tamanho infinitamente menor do que uma imagem python latest, temos também outras imagens menores do python, como o python:alpine, que muitas vezes(nem sempre) vem sem vulnerabilidades, então vemos uma logica aqui, quanto menor a imagem menor o numero de vulnerabilidades, e isto geralmente é verdade, pois são menos pacotes adjascentes e menos bibliotecas, pacotes para serem gerenciados, ou seja reduzimos o campo de ataque.</p><h2 id=criando-uma-imagem-base-com-wolfi-e-apko>Criando uma imagem base com wolfi e apko<a hidden class=anchor aria-hidden=true href=#criando-uma-imagem-base-com-wolfi-e-apko>#</a></h2><p>O apko tem uma linguagem de escrita em yaml, um arquivo declarativo que deixa em forma de pipeline o que desejamos fazer</p><p>Abaixo um exemplo do arquivo, que também pode ser visto no path <a href=./apko/apko-python.yaml>apko-python.yaml</a></p><pre tabindex=0><code>contents: 
  keyring:
    - https://packages.wolfi.dev/os/wolfi-signing.rsa.pub
  repositories:
    - https://packages.wolfi.dev/os

  packages:
    - wolfi-base
    - openssl
    - python3

environment:

  PATH: /usr/local/sbin:/usr/local/bin:/usr/bin:/usr/sbin:/sbin:/bin

archs:
  - amd64
</code></pre><p>Estamos dizendo que queremos construir um pacote com apko, contendo wolfi-base, openssl e python3, e com o seguinte variavel de ambiente para PATH.
Em seguida definimos a arquitetura amd64, podendo ser arm, entre outras.</p><p>Para buidar temos de ter a ferramenta instalada e rodamos</p><pre tabindex=0><code>apko build &lt;arquivo declarativo.yaml&gt; nome-imagem pacoteoutput.tar 

apko build apko-python.yaml python-base python-base.tar 
</code></pre><p>De forma muito rapida é criado um .tar contendo a imagem, e também seus arquivos de metadata do sbom, que contem toda info sobre as bibliotecas ali instaladas.</p><p><img alt=output loading=lazy src=/posts/boas-praticas-containers/images/outputapko.png></p><p>Em seguida para transformar o .tar em uma imagem, usamos o comando <code>docker load</code>
C</p><pre tabindex=0><code>docker load -i &lt;arquivo&gt;.tar 
</code></pre><p>E posteriormente vemos a imagem base já em nossas imagens disponiveis.</p><p><img alt=python-base loading=lazy src=/posts/boas-praticas-containers/images/python-base.png></p><p><img alt=python-base-version loading=lazy src=/posts/boas-praticas-containers/images/python-base-version.png></p><p>E desta forma para qualquer outra linguagem ou pacote.</p><p>A um tempo já construi uma imagem usando apko que continha o kubectl e o awscli, porém perdi este projeto, assim que tiver mais um tempo voltamos com este tema.</p><p>Esta ferramenta é bacana para construção de imagens base e também gerenciamento de supply chain, como SBOM, SLSA, preciso de maiores estudos nesta area de metadados do container e bibliotecas, e podemos também voltar com este assunto no futuro.</p><h1 id=conclusão>Conclusão<a hidden class=anchor aria-hidden=true href=#conclusão>#</a></h1><p>Existe um mundo de vulnerabilidades e mitigações a serem feitas numa imagem de container, seguir as boas praticas é fundamente para diminuirmos superficie de ataque e otimizarmos imagem.</p><p>Nem sempre é possível fazer tudo, porém o bom não pode ser inimigo do ótimo, e uma pequena ação deste estilo já causa beneficios que iremos colher na utilização de containers.</p><p>Espero que a documentação esteja clara e esclarecedora.</p><h3 id=referencias>Referencias<a hidden class=anchor aria-hidden=true href=#referencias>#</a></h3><p><a href=https://github.com/OWASP/Docker-Security/blob/main/dist/owasp-docker-security.pdf>OWASP-TOP10</a><br><a href=https://sysdig.com/learn-cloud-native/container-security-best-practices/>SysDig: Container security best practices</a><br><a href=https://medium.com/geekculture/the-docker-attack-surface-5184a36a23ca>Docker Attack Surface</a><br><a href=https://www.chainguard.dev/>Chainguard</a><br><a href=https://edu.chainguard.dev/open-source/build-tools/melange/getting-started-with-melange/>Chainguard - Melange</a><br><a href=https://github.com/chainguard-dev/apko>Chainguard - APKO</a><br><a href=https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html>Docker Security Cheat Sheet</a><br><a href=https://downloads.cisecurity.org/#/>CIS Security Benchmark - Docker</a><br><a href=https://owasp.org/www-community/Threat_Modeling_Process#stride-threat-list>STRIDE Framework</a><br><a href="https://www.aquasec.com/cloud-native-academy/docker-container/docker-architecture/#:~:text=The%20Docker%20client%20provides%20a,run%20on%20a%20Docker%20host.">Docker ArchitecturIn this guide, you’ll learn how to build a software package with melange. To deme - Aquaseq</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://craudio.com.br/tags/containers/>Containers</a></li><li><a href=https://craudio.com.br/tags/docker/>Docker</a></li></ul><nav class=paginav><a class=next href=https://craudio.com.br/posts/kube-jmeter/><span class=title>Next »</span><br><span>Kube Jmeter</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://craudio.com.br/>Blog do Craudio</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>